
#############################
# What's new in Java 11: LTS
#############################


- Deprecations and removals of outdated APIs
- New HttpClient API
- Ability to run source code directly without compiling
- 2 new GCs
- Language, Library, Performance, Security improvements



=====================================

# Certification path
- Only 1 exam needed for Java-11 certification:
1Z0-819

- 50 multiple choice questions: 90 minutes; passing marks = 68%


#######################################
# 01 - Java Data Types and String APIs
#######################################
- 8 primitive types
boolean
byte
short
int
long
double
float
char

- partial initialization will not compile
example:
void method1() {
 int var1;
 if(flag) {
    var1 = 10;
 }
 out.println(var1);
}

- random flag example
boolean flag = (new Random()).nextBoolean();

- byte range = -128 to 127 => (-2^7) to (2^7-1)
- short range = -32768 to 32767 => (-2^15) to (2^15-1)
- int range = (-2^31) to (2^31-1)




#######################################################################################

################
# 02 - Java IO
################

## Introduction
- data = bytes and chars
- read/write data to memory + disk + network
- network is not in certification scope

- Java IO - Java v1 - 1995
- Java NIO - Java v1.4 - 2004
- Java NIO2 - Java v7 - 2011

- Reading chars = Reader
- Writing chars = Writer

- Reading bytes = InputStream
- Writing bytes = OutputStream

- Reading characters from a File
                 Reader
    |               |              |
FileReader    StringReader    CharArrayReader

- to create a Reader, need:
a File to create a FileReader
a String to create a StringReader
a char[] to create a CharArrayReader

- Reader class has abstract methods:
close()
read(char[], int, int)

- non-abstract methods:
read()
read(char[])
read(CharBuffer)


## File and Path
- to deal with files, 2 APIs:
File from Java IO
Path from Java NIO2

- key points for File
create and delete file
create dir
analyze the path
get the real path to a file or dir
creating a new File("...") does NOT creates a file

- with Files
copy and move files

- demo code
PlayWithFiles

- Why another model for a Path?
File does not know the underlying OS file system and is independent of it
so, not possible to access specific features of underlying OS
Solution: one interface with specific implementations of each file systems

- demo code
PlayWithPath

- 2 ways to create path
Path path1 = Paths.get("c:/images/seaside.jpg");

// new in Java 11
Path path2 = Path.of("mountain.jpg");


## Reading and Writing Characters
- Reader and Writer
- demo code
PlayWithReader
PlayWithWriter

- new way to create buffered reader/writer
BufferedReader reader = Files.newBufferedReader(path)
BufferedWriter writer = Files.newBufferedWriter(path)

- 2 ways to read from buffered reader
String line = reader.readLine();
Stream<String> lines = reader.lines();


## Reading and Writing Bytes
- InputStream and OutputStream
- FileInputStream and ByteArrayInputStream
- there are data and object streams also

- demo code

- OutputStreamWriter needs to wrap up an OutputStream like ByteArrayOutputStream
- InputStreamReader needs to wrap up an InputStream like ByteArrayInputStream




