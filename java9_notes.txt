Course 0:
Pluralsight courses by Sander Mak

################################
# Java 9 Modularity: First Look
################################
- Module systems
- HTTP/2 client, updates to Stream APIs, Collection factories

- before JDK9, there was 1 monolithic jar containing all the JDK classes = rt.jar
- from JDK9, it is modular now with more than 90 platform modules
- main base module on which all modules depend on = java.base

# java.base
first half public = packages like java.lang, java.util, java.io etc
second half private (internal and not accessible) = sun.util, jdk.internal, etc

# define a module by module descriptor
- file name = module-info.java
- exports <package name>
- requires <module name>

- example1:
module java.base {
   exports java.lang;
   exports java.util;
   exports java.io;
   // and more
}

- example2:
module java.sql {
   exports java.sql;
   exports javax.sql;
   exports javax.transaction.xa;

   requires java.logging;
   requires java.xml;
}


------------

### Easy Text Module

- main package is like this:
package javamodularity.easytext;

- created a new module-info.java at same level as javamodularity
easytext/javamodularity
easytext/module-info.java

module easytext {
  requires java.base;
}

- command line compile before source folder src/
javac --module-source-path src -d out $(find . -name '*.java')
javac --module-source-path src -d out $(find . ! \( -path ./src/easytext.gui -prune \) -name '*.java')

- command line run
java --module-path out -m easytext/javamodularity.easytext.Main ../../../../ocp11_notes.txt
java --module-path out -m easytext.cli/javamodularity.easytext.cli.Main testinput.txt

## Transitive dependencies
app -> java.sql -> java.logging, java.xml

- suppose app needs access to java.logging and java.xml too
- module descriptors are like this:
module app {
   requires java.sql;
}

module java.sql {
   requires transitive java.logging;
   requires transitive java.xml;
   exports java.sql;
}

- handy command to list all java dependencies
java --list-modules

- exclusive exports can export to a specific package
- example:
module easytext.gui {
   exports javamodularity.easytext.gui to javafx.graphics;
   ...
}

- dependency injection shown in module 4 using service api and interfaces
- use provides with

########
# jlink
########
https://www.baeldung.com/jlink

- jlink is a tool that generates a custom Java runtime image that contains only the platform modules that are required for a given application
- in other words, create a very small "JRE-like-image" containing only the required modules
- With jlink, we can create our own, small JRE that contains only the relevant classes that we want to use,
without wasting memory, and as a result, we'll see increased performance

- use jdeps to get list of modules needed for application
- example
jdeps --module-path out -s --module jlinkModule

- create a custom jre, syntax:
jlink [options] --module-path modulepath
  --add-modules module [, moduleâ€¦]
  --output <target-directory>

- example
jlink --module-path "%JAVA_HOME%\jmods";out
  --add-modules jlinkModule
  --output customjre


